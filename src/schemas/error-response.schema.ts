import { z } from 'zod';

/**
 * Zod schema for standardized error information for all failure scenarios
 * Based on data-model.md specification
 *
 * Source: Generated by application for any error condition
 */

// Error source enum
const ErrorSourceSchema = z.enum(['GUS', 'KRS', 'CEIDG', 'INTERNAL']);

// Predefined error codes for different scenarios
export const ERROR_CODES = {
  // Input validation errors
  INVALID_NIP_FORMAT: 'INVALID_NIP_FORMAT',
  INVALID_REQUEST_FORMAT: 'INVALID_REQUEST_FORMAT',
  MISSING_REQUIRED_FIELDS: 'MISSING_REQUIRED_FIELDS',

  // Authentication/authorization errors
  INVALID_API_KEY: 'INVALID_API_KEY',
  MISSING_API_KEY: 'MISSING_API_KEY',
  API_KEY_EXPIRED: 'API_KEY_EXPIRED',
  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',

  // Rate limiting
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',

  // External service errors
  GUS_SERVICE_UNAVAILABLE: 'GUS_SERVICE_UNAVAILABLE',
  GUS_AUTHENTICATION_FAILED: 'GUS_AUTHENTICATION_FAILED',
  GUS_SESSION_EXPIRED: 'GUS_SESSION_EXPIRED',
  GUS_SOAP_FAULT: 'GUS_SOAP_FAULT',
  GUS_VALIDATION_FAILED: 'GUS_VALIDATION_FAILED',
  GUS_CONNECTION_ERROR: 'GUS_CONNECTION_ERROR',
  GUS_WSDL_PARSE_ERROR: 'GUS_WSDL_PARSE_ERROR',

  KRS_SERVICE_UNAVAILABLE: 'KRS_SERVICE_UNAVAILABLE',
  KRS_INVALID_REGISTRY: 'KRS_INVALID_REGISTRY',
  KRS_RATE_LIMIT: 'KRS_RATE_LIMIT',
  KRS_INVALID_RESPONSE: 'KRS_INVALID_RESPONSE',
  KRS_VALIDATION_FAILED: 'KRS_VALIDATION_FAILED',

  CEIDG_SERVICE_UNAVAILABLE: 'CEIDG_SERVICE_UNAVAILABLE',
  CEIDG_AUTHENTICATION_FAILED: 'CEIDG_AUTHENTICATION_FAILED',
  CEIDG_JWT_EXPIRED: 'CEIDG_JWT_EXPIRED',
  CEIDG_RATE_LIMIT: 'CEIDG_RATE_LIMIT',
  CEIDG_VALIDATION_FAILED: 'CEIDG_VALIDATION_FAILED',

  // Business logic errors
  ENTITY_NOT_FOUND: 'ENTITY_NOT_FOUND',
  ENTITY_DEREGISTERED: 'ENTITY_DEREGISTERED',
  CLASSIFICATION_FAILED: 'CLASSIFICATION_FAILED',
  DATA_MAPPING_FAILED: 'DATA_MAPPING_FAILED',
  ORCHESTRATION_FAILED: 'ORCHESTRATION_FAILED',

  // System errors
  TIMEOUT_ERROR: 'TIMEOUT_ERROR',
  NETWORK_ERROR: 'NETWORK_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  SERVICE_DEGRADED: 'SERVICE_DEGRADED',
  CRITICAL_SERVICE_UNAVAILABLE: 'CRITICAL_SERVICE_UNAVAILABLE',

  // Retry and circuit breaker
  MAX_RETRIES_EXCEEDED: 'MAX_RETRIES_EXCEEDED',
  CIRCUIT_BREAKER_OPEN: 'CIRCUIT_BREAKER_OPEN',

  // Service invocation errors (XState orchestration)
  SERVICE_NOT_FOUND: 'SERVICE_NOT_FOUND',
  METHOD_NOT_FOUND: 'METHOD_NOT_FOUND',
  SERVICE_FAILED_AFTER_RETRIES: 'SERVICE_FAILED_AFTER_RETRIES',
  RETRY_MACHINE_FAILED: 'RETRY_MACHINE_FAILED',
} as const;

// Error code validation schema
const ErrorCodeSchema = z.enum(
  Object.values(ERROR_CODES) as [string, ...string[]],
);

// Main ErrorResponse schema
export const ErrorResponseSchema = z
  .object({
    errorCode: ErrorCodeSchema.describe(
      'Machine-readable error identifier from predefined codes',
    ),

    message: z
      .string()
      .min(1)
      .max(500)
      .describe('Human-readable error description (max 500 characters)'),

    correlationId: z.string().min(1).describe('Request tracking ID'),

    source: ErrorSourceSchema.optional().describe(
      'Error origin (GUS, KRS, CEIDG, or INTERNAL)',
    ),

    timestamp: z
      .string()
      .datetime()
      .describe('ISO 8601 timestamp when error occurred'),

    // Additional context for debugging (not exposed to end users)
    details: z
      .record(z.string(), z.any())
      .optional()
      .describe('Additional error details for internal debugging'),
  })
  .refine(
    (data) => {
      // Validate that source matches error code prefix for external services
      if (
        data.errorCode.startsWith('GUS_') &&
        data.source &&
        data.source !== 'GUS'
      ) {
        return false;
      }
      if (
        data.errorCode.startsWith('KRS_') &&
        data.source &&
        data.source !== 'KRS'
      ) {
        return false;
      }
      if (
        data.errorCode.startsWith('CEIDG_') &&
        data.source &&
        data.source !== 'CEIDG'
      ) {
        return false;
      }
      return true;
    },
    {
      message:
        'Error source must match error code prefix for external services',
      path: ['source'],
    },
  );

// TypeScript types
export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;
export type ErrorSource = z.infer<typeof ErrorSourceSchema>;
export type ErrorCode = keyof typeof ERROR_CODES;

// Helper functions for creating ErrorResponse objects
export function createErrorResponse(params: {
  errorCode: ErrorCode;
  message: string;
  correlationId: string;
  source?: ErrorSource;
  details?: Record<string, any>;
}): ErrorResponse {
  return ErrorResponseSchema.parse({
    ...params,
    timestamp: new Date().toISOString(),
    details: params.details,
  });
}

// Predefined error response creators for common scenarios
export const ErrorResponseCreators = {
  invalidNip: (correlationId: string, nip?: string) =>
    createErrorResponse({
      errorCode: 'INVALID_NIP_FORMAT',
      message: `Invalid NIP format. Expected 10 digits, received: ${nip || 'undefined'}`,
      correlationId,
      source: 'INTERNAL',
    }),

  entityNotFound: (correlationId: string, nip: string) =>
    createErrorResponse({
      errorCode: 'ENTITY_NOT_FOUND',
      message: `No entity found for NIP: ${nip}`,
      correlationId,
      source: 'INTERNAL',
    }),

  entityDeregistered: (correlationId: string, nip: string) =>
    createErrorResponse({
      errorCode: 'ENTITY_DEREGISTERED',
      message: `Entity with NIP ${nip} is deregistered and cannot be processed`,
      correlationId,
      source: 'INTERNAL',
    }),

  serviceUnavailable: (
    correlationId: string,
    service: ErrorSource,
    originalError?: Error,
  ) =>
    createErrorResponse({
      errorCode: `${service}_SERVICE_UNAVAILABLE` as ErrorCode,
      message: `${service} service is currently unavailable`,
      correlationId,
      source: service,
      details: originalError
        ? {
            originalMessage: originalError.message,
            stack: originalError.stack,
          }
        : undefined,
    }),

  rateLimitExceeded: (correlationId: string, service?: ErrorSource) =>
    createErrorResponse({
      errorCode: service
        ? (`${service}_RATE_LIMIT` as ErrorCode)
        : 'RATE_LIMIT_EXCEEDED',
      message: service
        ? `Rate limit exceeded for ${service} service`
        : 'API rate limit exceeded',
      correlationId,
      source: service || 'INTERNAL',
    }),

  timeoutError: (correlationId: string, service?: ErrorSource) =>
    createErrorResponse({
      errorCode: 'TIMEOUT_ERROR',
      message: service
        ? `Request to ${service} service timed out`
        : 'Request timed out',
      correlationId,
      source: service || 'INTERNAL',
    }),

  internalError: (correlationId: string, originalError?: Error) =>
    createErrorResponse({
      errorCode: 'INTERNAL_SERVER_ERROR',
      message: 'An internal server error occurred',
      correlationId,
      source: 'INTERNAL',
      details: originalError
        ? {
            originalMessage: originalError.message,
            stack: originalError.stack,
          }
        : undefined,
    }),

  invalidApiKey: (correlationId: string) =>
    createErrorResponse({
      errorCode: 'INVALID_API_KEY',
      message: 'Invalid or missing API key',
      correlationId,
      source: 'INTERNAL',
    }),

  maxRetriesExceeded: (correlationId: string, service: ErrorSource) =>
    createErrorResponse({
      errorCode: 'MAX_RETRIES_EXCEEDED',
      message: `Maximum retry attempts exceeded for ${service} service`,
      correlationId,
      source: service,
    }),
};

// Validation helpers
export function validateErrorResponse(data: unknown): ErrorResponse {
  return ErrorResponseSchema.parse(data);
}

export function isValidErrorResponse(data: unknown): data is ErrorResponse {
  return ErrorResponseSchema.safeParse(data).success;
}

// HTTP status code mapping for error codes
export function getHttpStatusForErrorCode(errorCode: ErrorCode): number {
  const statusMappings: Record<string, number> = {
    // 400 - Bad Request
    INVALID_NIP_FORMAT: 400,
    INVALID_REQUEST_FORMAT: 400,
    MISSING_REQUIRED_FIELDS: 400,

    // 401 - Unauthorized
    INVALID_API_KEY: 401,
    MISSING_API_KEY: 401,
    API_KEY_EXPIRED: 401,
    GUS_AUTHENTICATION_FAILED: 401,
    CEIDG_AUTHENTICATION_FAILED: 401,
    CEIDG_JWT_EXPIRED: 401,

    // 403 - Forbidden
    INSUFFICIENT_PERMISSIONS: 403,

    // 404 - Not Found
    ENTITY_NOT_FOUND: 404,
    ENTITY_DEREGISTERED: 404,

    // 408 - Request Timeout
    TIMEOUT_ERROR: 408,
    GUS_SESSION_EXPIRED: 408,

    // 422 - Unprocessable Entity
    CLASSIFICATION_FAILED: 422,
    DATA_MAPPING_FAILED: 422,

    // 429 - Too Many Requests
    RATE_LIMIT_EXCEEDED: 429,
    GUS_RATE_LIMIT: 429,
    KRS_RATE_LIMIT: 429,
    CEIDG_RATE_LIMIT: 429,

    // 502 - Bad Gateway
    GUS_SERVICE_UNAVAILABLE: 502,
    KRS_SERVICE_UNAVAILABLE: 502,
    CEIDG_SERVICE_UNAVAILABLE: 502,
    GUS_SOAP_FAULT: 502,
    NETWORK_ERROR: 502,

    // 503 - Service Unavailable
    SERVICE_DEGRADED: 503,
    CRITICAL_SERVICE_UNAVAILABLE: 503,
    CIRCUIT_BREAKER_OPEN: 503,
    MAX_RETRIES_EXCEEDED: 503,
  };

  return statusMappings[errorCode] || 500; // Default to 500 Internal Server Error
}
